---
layout: post
title:  "AKS Deployment Center"
categories: azure
---

# Azure Kubernetes Service - Deployment Center

#### Azure Kubernetes Service (AKS) Deployment Center is a new feature that helps developers push their containers faster from code to Azure. AKS Deployment Center simplifies greatly the process around Containers & CI/CD pipelines.
To describe a “typical manual” workflow for myself around containers and Kubernetes would be something like this:
1.	Create a application to be containerized – Let it be a UDP Server .NET6 application in this example.
2.	Create a Dockerfile that can build an image around this application
{% highlight Dockerfile %}
FROM mcr.microsoft.com/dotnet/runtime:6.0

COPY bin/Release/net6.0/publish/ App/
WORKDIR /App
EXPOSE 11000/udp
ENTRYPOINT [ "dotnet", "l3moni-udp-server.dll"]
{% endhighlight %}
3.	Build the actual image based on the Dockerfile
4.	Tag the image for container registry such as. Azure Container Registry or DockerHub
5.	Push the image to container registry
6.	Write a Kubernetes deployment *.YAML file for the workload also containing the Service element for exposing the service to public (get the image from container registry).
7.	Run kubectl on a local machine to deploy in AKS

#### For something more production ready, I usually automate the image building and deployment by using a CI/CD pipeline in either Azure DevOps or GitHub Actions as one should.

### Enter Deployment Center
Using Deployment Center in AKS will _greatly_ simplify the workflows described above. 

As you click the “Deployment Center” in AKS, Portal will ask you the git/code location for your code.

![instructions-screenshot](/assets/aksdc/1.png)

Once you have selected the correct location of the code, you will next configure the proper branch from which to deploy from.

![instructions-screenshot](/assets/aksdc/2.png)

Next Deployment Center will showcase any Dockerfile found in that repo/branch and allows you to modify the service port.

![instructions-screenshot](/assets/aksdc/3.png)

Finally, Deployment Center will check on which namespace you want to push your workload to or create a new one if necessary. In this step the image that will get built based on the Dockerfile will be also stored in Azure Container Registry of your choice. 

![instructions-screenshot](/assets/aksdc/4.png)

When you click done, Portal will start creating a CI/CD pipeline that will do all of the steps <b>(steps 3-7 from my manual workflow) automatically</b> and be triggered whenever you push new code to your git repository.

![instructions-screenshot](/assets/aksdc/5.png)

This can greatly reduce your time especially from Dev to Test or even to final Production. Note that as this feature is still in preview, I would recommend against using this in production until the feature is in GA. 

One of the things I noticed from my example was that while the image got built and deployed correctly, the Service generated for the AKS deployment was not 100% correct as my Dockerfile stated that the exposed port was a “UDP” type but the port type that was opened by LoadBalancer was actually TCP, meaning that my Service did not function correctly until I manually fixed the Service .yml generated by Deployment Center.

If you want to try this out yourself, you can checkout my repo here: [l3moni-udp-server](https://github.com/L3mondrop/l3moni-udp-server)
